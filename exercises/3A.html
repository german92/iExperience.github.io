<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>3A Homework</title>
  <link rel="stylesheet" href="../stylesheets/exercises.css">
  <link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
</head>
<body>
  <div class="header">
    <div class="container">
      <h1>
        Homework for 3A
        <img src="../images/logo.png" alt="" class="logo">
      </h1>
    </div>
  </div>
  <div class="container">
    <h1>Review</h1>
    <p>
      <b>Topics Covered:</b> calling methods; objects; classes
    </p>
    <h1>Exercises</h1>
    <h2>E1: Guess the Class</h2>
    <p>
      What's the output of each of the following? Check in <code>irb</code>.
    </p>
    <pre><code>1.class
"hi".class
(7>6).class
(6>7).class
>.class
x = ["a", "b"]
x.class
x.reverse.class
x.join.class
x.length.class <span class="comment"># .length is the same as .size</span>
x.class.class
x.class.class.class</code></pre>
    <p class="info hint">
      Classes are why things like <code>1 + "hi"</code> don't work—now the error message <code>TypeError: String can't be coerced into Fixnum</code> might start making some sense. Methods like <code>.to_i</code> and <code>.to_s</code> make it easy to convert between classes.
    </p>
    <h2>E2: Split Up</h2>
    <p>
      Use your best friend Google (or Bing, if you're one of those) to research the method <code>split</code> in Ruby. Then answer the following questions:
    </p>

    <ol>
      <li>What class of objects can it be called on?</li>
      <li>What class does it return?</li>
      <li>Does it take any arguments? How many? Are they required or optional?</li>
      <li>If it takes arguments, what class should they be?</li>
      <li>Give example usage.</li>
      <li>Can you think of a method we've learned that behaves like the opposite of <code>split</code>?</li>
    </ol>
    <a class="hover-show pull-right">Hover for answer</a>
    <div class="hover-hide">
      <ol>
        <li><code>split</code> is called on Strings.</li>
        <li>It returns an Array.</li>
        <li>It can take 2 arguments. Both are optional.</li>
        <li>The first argument may be a String, Regexp or nil (don't worry about what a Regexp is yet). The second argument, if provided, must be a Fixnum.</li>
        <li>
          <pre><code>"Coding is cool".split(" ")
 => ["Coding", "is", "cool"]</code></pre>
        </li>
        <li>
          <code>join</code>, which takes an array and merges all of its items into a string, can behave like its opposite:
          <pre><code>"Coding is cool".split(" ").join(" ")
 => "Coding is cool"</code></pre>
          Notice how we can chain methods (use one after another wihtout assigning the intermediate result to a variable)—it's a very powerful technique!
        </li>
      </ol>
    </div>
    <h2>E3: Tic-Tac-Toe</h2>
    <p>
      This one's more a mini-project: we're going to work through building a simple tic-tac-toe application from scratch. Pick a partner who you haven't worked with before, create <code>tictactoe.rb</code> in <code>d3</code> and let's get started!
    </p>
    <h4>Step 1: Planning</h4>
    <p>
      As usual, we're going to plan out our approach before we begin coding. Read the following carefully—your program must:
      <ul>
        <li>Take input from two players</li>
        <li>Detect invalid input</li>
        <li>Keep track of whose turn it is</li>
        <li>Keep track of a board</li>
        <li>Keep track of which squares have been filled in on the board, and not let the same square be filled in more than once</li>
        <li>Detect a winner when a player has won</li>
      </ul>
      The input will be an integer from 0-8 and the squares will be numbered top-left to bottom-right (0 is the top-left square, 2 is the top-right square, 4 is the middle square, and 8 is the bottom-right square).  
    </p>
    <p>
      In <code>tictactoe.rb</code>, answer the following questions:
    </p>
    <pre><code><span class="comment"># tictactoe.rb</span>

# How will you keep track of whose turn it is?
# What data structure will you use to keep track of the board? You only
#   know two (Array, Hash), but remember they can be nested (meaning an
#   array can contain another array—it can even contain a hash that contains
#   another hash)
# When a player makes a move, what should happen? 
# How do you keep track of which squares have x's and which have o's?
# How do you detect a winner?
# When does the program stop? Is there a loop? If so, what kind?</code></pre>
    <h4>Step 2: Pseudo-code</h4>
    <p>
      <em>Pseudo-code</em> is code that's written in English; that is, step by step instructions for how your program behaves. An example:
    </p>
    <pre><code># Every turn:
#   Update whose turn it is
#   Get user input
#   Update board
#   Check for winner</code></pre>
    <p>
      Of course, that's pretty easy to write, but may not be so obvious to translate into code. What exactly is a turn? How does one update the board? These are questions you've started thinking about in Step 1. For Step 2, expand your thinking and the above pseudo-code to make a more detailed outline. That is, your writing may contain words like "Array" and "Hash", but probably doesn't contain any "[" or "{". As you write, consider these questions, and be ready to answer them:
      <ul>
        <li>Do you need to make any classes or modules?</li>
        <li>
          What functionality are you using often? Do you need any helper methods?
        </li>
        <li>
          Again: is there a loop? What kind of loop? Does it end? When? How? If no loop, how is your program structured?
        </li>
      </ul>
    </p>
    <p class="hint info">
      It may be starting to become clear that coding is much more about <b>thinking</b> than anything else. While there isn't necessarily a best solution, there are solutions that are much more intuitive and easier to understand than others. Remember that code is meant to be read by <b>humans</b>, and when two pieces of code do the same thing with the same efficiency, the one that's simpler is always better.
    </p>
    <p>
      <b>Check in with a TA before continuing!</b>
    </p>
    <h4>Step 3: Code</h4>
    <p>
      Now that you have your pseudo-code, it should be a simple matter to turn it into real code. Take a crack, and see if it works. 
    </p>
    <pre><code>$ ruby tictactoe.rb 
Player 1:
0
Player 2:
1
Player 1:
kittens
Error: Invalid input
Player 1:
10
Error: Invalid input
Player 1:
3
Player 2:
2
Player 1:
2
Error: Square already taken
Player 1:
6
Congrats, player 1 won!</code></pre>
    
    <p class="info hint">
      If you've gotten this far, you actually know quite a bit about coding, and the coding process. This was actually a Google coding interview problem (though keep that fact hush hush!). When you interview at companies—or try to code anything, really—this workflow is a good one to keep in mind: first <b>talk through</b> your solution and think about what <b>data structures</b> you'll use. Then write <b>pseudo-code</b> and try to foresee as many problems as you can. Only when you're confident in your <b>thinking</b> should you start coding.
    </p>
    <h4>Step 4: User Experience</h4>
    <p>
      To be honest, while your program is cool, it's not very user friendly...humans aren't very good at remembering what the board looks like. Add a method to print out the board after each step. We've picked a design, but feel free to make it look like however you want!
    </p>
    <pre><code>$ ruby tictactoe.rb
Player 1:
4
     |   |   
  ———+———+———
     | X |   
  ———+———+———
     |   |   
Player 2:
0
   O |   |   
  ———+———+———
     | X |   
  ———+———+———
     |   |   
Player 1:
2
   O |   | X 
  ———+———+———
     | X |   
  ———+———+———
     |   |   
Player 2:
6
   O |   | X 
  ———+———+———
     | X |   
  ———+———+———
   O |   |   
Player 1:
3
   O |   | X 
  ———+———+———
   X | X |   
  ———+———+———
   O |   |   
Player 2:
5
   O |   | X 
  ———+———+———
   X | X | O 
  ———+———+———
   O |   |   
Player 1:
1
   O | X | X 
  ———+———+———
   X | X | O 
  ———+———+———
   O |   |   
Player 2:
7
   O | X | X 
  ———+———+———
   X | X | O 
  ———+———+———
   O | O |   
Player 1:
8
   O | X | X 
  ———+———+———
   X | X | O 
  ———+———+———
   O | O | X 
Cats game!</code></pre>

    <h2 class="bonus">E5 (Bonus!): Computer Tic-Tac-Toe</h2>
    <p>
      While playing against a person is fun, us loners need something to do. Write a program that <b>plays tic tac toe against you</b>. It should be smart, or else that's not fun!
    </p>
    <pre><code>$ ruby computer_tictactoe.rb
Would you like to be Player 1 or Player 2?
1
Player 1:
4
Computer: 0
   O |   |   
  ———+———+———
     | X |   
  ———+———+———
     |   |   
Player 1:
2
Computer: 6
6
   O |   | X 
  ———+———+———
     | X |   
  ———+———+———
   O |   |   
Player 1
5
Computer: 8
3
   O |   | X 
  ———+———+———
   O | X | X 
  ———+———+———
   O |   |   
The computer wins!
</code></pre>
    <p>
      As you can see, it's pretty tough to get a computer to even be smart about something as simple as tic-tac-toe—the human brain is really amazing. Now consider how much code and intelligence is required to make a program that plays chess, or gives directions to some place depending on traffic and road closings...it's actually quite humbling.
    </p>

    <!-- Projects -->
    <h1>Projects</h1>
    <h2>Ruby: Fueling Consumerism</h2>
    <p>
      Now that you have a beautiful presence on the Internet, we're going to work on bringing one of the most notable American vices to South Africa: consumerism. Over the next two days, you'll use your new knowledge of Ruby—with all its Hashes and Classes—to build a Shopping Cart and some Shoppers. It will closely model something you might build in a Rails application some day.
    </p>
    <h4>
      The Goods
    </h4>
    <p>
      To start, create a <code>shopping_cart</code> folder in your <code>projects</code> directory. We'll start with an <code>Item</code> class, so in <code>shopping_cart</code>, create a file called <code>item.rb</code>. Item is the simplest: it just has a <code>name</code> and a <code>price</code>. Copy the below code into it:
    </p>
    <pre><code><span class="comment"># item.rb</span>

class Item
  # @param{string} name The item's name
  # @param{float} price The item's price
  def initialize(name, price)
  end

  # Accessor methods

  # Returns name
  def name
  end

  # Returns price
  def price
  end
end</code></pre>
    <p>
      This code doesn't do anything yet, but should be simple to fill out. Go ahead and do so, just like we did in lecture.
    </p>
    <h4>
      The Vehicle
    </h4>
    <p>
      Next we're going to build a <code>Cart</code> class that will hold all of the items, as well as how many items there are. Put this in a new file, <code>cart.rb</code>. This cart will closely resemble Lesson 2B, Exercise 4, so feel free to borrow and modify code from there. To start, here's a template:
    </p>
    <pre><code><span class="comment"># cart.rb</span>

class Cart
  def initialize
  end

  # @return{Hash&lt;string, Hash&lt;:item => Item, :quantity => Float&gt;&gt;}
  #   The items and their quantities in the cart, keyed by item name.
  def items
  end

  # @return{float} The total price of all the goods in the cart.
  def total_price
  end

  # @param{Item} item The item to add. 
  def add(item)
  end

  # @param{Item} item The item to remove. 
  def remove(item)
  end
end</code></pre>
  <p>
    The exact specification is as follows:
    <ul>
      <li>
        Cart should keep a class variables called <code>@items</code>.
        <code>@items</code> will be <code>Hash</code>, where the keys are the item names (strings).
      </li>
      <li>
        The values of that hash will themselves be hashes (which we'll call <code>item_obj</code>s), with two keys: <code>:item</code> and <code>:quantity</code>. The value of <code>:item</code> will be the <code>Item</code> object, and the value of <code>:quantity</code> will be the number of that item in the cart. The value of quantity should never be below 0.
      </li>
      <li>
        <code>add</code> will increment the quantity if the item already exists, or create a new, properly created <code>item_obj</code>.
      </li>
      <li>
        <code>remove</code> will decrement the quantity if the item exists and has a quantity of at least 1. Otherwise, it will do nothing.
      </li>
      <li>
        <code>total_price</code> returns a <code>float</code> of the total price of all items in the cart. 
      </li>
    </ul>
  </p>
  <p>
    Like in the slides, let's create a <code>main.rb</code> that we'll use to test. This is a sample of how you might test it:
  </p>
  <pre><code><span class="comment"># main.rb</span>

require_relative 'item'
require_relative 'cart'
milk = Item.new("milk", 1.20)
eggs = Item.new("eggs", 1.30)
cart = Cart.new
cart.add(milk)
cart.add(milk)
cart.add(eggs)
p cart.items
<span class="string"># Console output might look like (but less well formatted):
# {
#   "milk" => {
#     :item => #&lt;Item:0x00...>,
#     :quantity => 2
#   },
#   "eggs" => {
#     :item => #&lt;Item:0x00...>,
#     :quantity => 1
#   }
# }</span>
p cart.total_price
<span class="string"># 3.7</span>
cart.remove(milk)
p cart.total_price
<span class="string"># 2.5</span></code></pre>
  <p>
    After you think you have a working answer, download the test file from <a href="../files/shopping_cart_test_1.rb" target="_blank">here</a> and put it in your <code>shopping_cart</code> directory (just do File -> Save from Chrome). Run it with <code>ruby shopping_cart_test_1.rb</code>. If you're failing any tests, make them pass!
  </p>
  </div>
  <div class="footer">
    <div class="container">
      <a href="./2B.html" class="btn big">&larr; Previous lesson</a>
      <a href="../index.html" class="btn big">Back to contents</a>
      <a href="./3B.html" class="btn big">Next lesson &rarr;</a>
    </div>
  </div>
</body>
</html>
