---
title: Homework for 3A
layout: exercise
prev: 2B
next: 3B
permalink: /exercises/3A.html
answers_shown: false
---
<h1>Review</h1>
<p>
  <b>Topics Covered:</b> calling and creating methods; objects; classes
</p>
<hr class="large">

<!-- Exercises -->
<h1>Exercises</h1>
<h2>E1: Guess the Class</h2>
<p>
  What's the output of each of the following? Check in <code>irb</code>.
</p>
<pre><code>1.class
1.0.class
-1.class
-1.1.class
"hi".class
(7>6).class
(6>7).class
>.class
x = ["a", "b"]
x.class
x.reverse.class
x.join.class
x.length.class <span class="comment"># .length is the same as .size</span>
x.class.class
x.class.class.class</code></pre>
<p class="info hint">
  Classes are why things like <code>1 + "hi"</code> don't work—now the error message <code>TypeError: String can't be coerced into Fixnum</code> might start making some sense. Methods like <code>.to_i</code> and <code>.to_s</code> make it easy to convert between classes.
</p>
<h2>E2: Fishies</h2>
<p>
  Suppose I had a class called <code>FishClass</code>. Give an example of:
  <ul>
    <li>An <b>instance</b> of that class</li>
    <li>A method that that class might have</li>
  </ul>
</p>
<h2>E3: Split Up</h2>
<p>
  Use your best friend Google (or Bing, if you're one of those) to research the method <code>split</code> in Ruby. Then answer the following questions:
</p>

<ol>
  <li>What class of objects can it be called on?</li>
  <li>What class does it return?</li>
  <li>Does it take any arguments? How many? Are they required or optional?</li>
  <li>If it takes arguments, what class should they be?</li>
  <li>Give example usage.</li>
  <li>Can you think of a method we've learned that behaves like the opposite of <code>split</code>?</li>
</ol>
<p>
  Only <b>after</b> you've written down your answers should you check them. If you don't know, give it your best shot—you're not being graded, so you're only helping yourself :)
</p>
{% if page.answers_shown %}
<a class="hover-show pull-right">Hover for answer</a>
<div class="hover-hide">
  <ol>
    <li><code>split</code> is called on Strings.</li>
    <li>It returns an Array.</li>
    <li>It can take 2 arguments. Both are optional.</li>
    <li>The first argument may be a String, Regexp or nil (don't worry about what a Regexp is yet). The second argument, if provided, must be a Fixnum.</li>
    <li>
      <pre><code>"Coding is cool".split(" ")
=> ["Coding", "is", "cool"]</code></pre>
    </li>
    <li>
      <code>join</code>, which takes an array and merges all of its items into a string, can behave like its opposite:
      <pre><code>"Coding is cool".split(" ").join(" ")
=> "Coding is cool"</code></pre>
      Notice how we can chain methods (use one after another wihtout assigning the intermediate result to a variable)—it's a very powerful technique.
    </li>
  </ol>
</div>
{% endif %}
<h2>E4: Twist and Whisper</h2>
<p>
  Somewhat like the <code>shout</code> method, write a method <code>whisper</code> that prints out an input string in lower case.
</p>
<pre><code>whisper("HI THERE I AM HUNGRY")
<span class="comment"># => "hi there how r u"</span></code></pre>
<p>
  Next, write a method <code>twist</code> that takes a string and prints out the letters randomly. The output should be different each time you run the function.
</p>
<pre><code>twist("HI THERE I AM STILL HUNGRY")
<span class="comment"># => "EUSI LLAM NTGY IR H IHRTHE"</span></code></pre>
<p class="info hint">
  Hint: There is a convenient method named <code>shuffle</code> that mixes up all the elements randomly, but only works for <b>arrays</b> and not strings. However, can you think of an easy way that we've already learned to convert a string to an array of letters? After you <b>split up</b> the string into an array, how do you suppose we can <b>join</b> them back together? This is a good case of <b>chaining</b> methods, or calling one method one after another, like you might have done with <code>gets.strip.downcase</code>.
</p>
<h2>E5: hsaH</h2>
<p>
  Write a method <code>invert</code> that inverts the keys and values of a Hash. 
</p>
<h4>Testing</h4>
<p>
  A huge part of writing code is testing to make sure it works, in particular <b>edge cases</b>. Edge cases are common inputs that break a program: things like passing in <code>nil</code>, negative numbers, very large numbers, etc. What kinds of test cases and edge cases can you think of for this method? Here are some:
  <ul>
    <li><code>nil</code></li>
    <li><code>{:a => ["b", "c"]}</code></li>
    <li><code>{:a => ["b", {:c => "d"}]}</code></li>
  </ul>
  <p>
    Coincidentally, Ruby comes with a built-in method called <code>invert</code> on the <code>Hash</code> class. Try these test cases on those (i.e. <code>{:a => ["b", "c"]}.invert</code>). How does your program's output compare to Ruby's? Can you think of any other test cases?
  </p>
</p>

<h2 class="bonus">E6 (Bonus!): The Fibonacci Re-code</h2>
<p>
  Now that you know more about methods, take the Fibonacci code you wrote earlier and make it into a method in <code>d3/fibonacci_method.rb</code>. Your code should still behave the same way, but wrap your code in a <code>while true</code> loop so that it doesn't exit every time:
</p>
<pre><code>$ ruby fibonacci_method.rb
Enter a number:
10
Fibonacci at 10: 55
Enter a number:
11
Fibonacci at 11: 89</code></pre>
<p>
  For this exercise, we're going to explore the topic of <em>recursion</em>, or calling a method <em>in itself</em>. For example, suppose I wanted to write a method that returned the sum of all the numbers up to the one it was given. I might write this:
</p>
<pre><code><span class="comment"># sum_loop.rb</span>

def sum_up_to(num)
  sum = 0
  num.times do |i|
    sum += (i+1)
  end
  return sum
end

sum_up_to 10
<span class="comment"># => 55</code></pre>
<p>
  But a more elegant way might be:
</p>
<pre><code><span class="comment"># sum_recursive.rb</span>

def sum_up_to(num)
  return 0 if num == 0
  return num + sum_up_to(num-1)
end</code></pre>
<p>
  That little bit of code packs a lot of punch. It stems from the observation that the sum of the numbers <code>0...5</code> is the same as <code>5 +</code> the sum of <code>0...4</code>. In general:
  <ul>
    <code>sum(0 + &middot;&middot;&middot; + n) = n + sum(0 + &middot;&middot;&middot; + n-1)</code>
  </ul>
  Recursion stems from the <em>induction principle</em>, which you might remember from way back when. Basically, it requires two things: a <b>base case</b> and <b>an inductive step</b>. Our base case is easy: the sum of all the numbers up to 0 is 0. We know that, it's always true, and we can hard code it in. The inductive step is the answer to: <b>if we know the answer for <code>n</code>, how can we find the answer for <code>n+1</code>?</b> For our case, that's easy again: just add <code>n+1</code> to the answer for <code>n</code> (or rather, <code>n</code> to the answer for <code>n-1</code>).
</p>
<pre><code><span class="comment"># sum_recursive.rb</span>

def sum_up_to(num)
  return 0 if num == 0          <span class="string"># Base case</span>
  return num + sum_up_to(num-1) <span class="string"># Inductive (or recursive) step.</span>
end</code></pre>
<p>
  You might be able to guess what the Fibonacci re-code is: Can you implement the fibonacci method so that it uses recursion?
</p>

<h2 class="bonus">E7 (Bonus!): hsaH no hsaH no hsaH</h2>
<p>
  Knowing what you know about recursion, write a method that inverts all the keys and values for a hash, as well as those for any hashes in it. It should use the <code>invert</code> method you wrote above.
</p>
<pre><code><span class="comment"># invert_recursive.rb</span>

# Your code here...

{:a => {:b => "c"}}.invert_recursive
<!-- We need to use &#123; for '{' here or else Jekyll complains. -->
<span class="string"># => {&#123;"c" => :b} => :a}</span>
{:a => ["b", {:c => "d"}]}.invert_recursive <span class="string"># Be careful!</span>
<span class="string"># => {["b, {"d" => :c}] => :a}</span>
</code></pre>
<p>
  Test, find edge cases, be merry!
</p>
