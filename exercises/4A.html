---
title: Homework for 4A
layout: exercise
prev: 3B
next: 4B
permalink: /exercises/4A.html
answers_shown: false
---

<h1>Review</h1>
<p>
  <b>Topics Covered:</b> Defining methods, classes, and modules; using methods, classes, and modules effectively.
</p>
<hr class="large">

<!-- Exercises -->
<h1>Exercises</h1>
<h2>E1: A Mass for the Masses</h2>
<p>
  We're going to review what we learned in class about classes.
  Check out this code, and <b>write down</b> the answers to the questions below, in a file called <code>mass_quiz</code>. Have a teacher check them for you.
</p>
<pre><code>class Person
  def initialize(name)
    @name = name <span class="string"># Line 3</span>
  end

  def name
    return @name
  end
end

class Christian < Person
  def initialize(name, type)
    @name = name
    @type = type
  end

  def go_to_mass
    puts "Going to mass..."
  end
end 

abdullah = Christian.new("abdullah", "original")</code></pre>
<p>
  <ol>
    <li>Why is line 3 necessary? What happens without it?</li>
    <li>Is <code>Christian</code> a subclass or a superclass?</li>
    <li>What will running <code>Christian.go_to_mass</code> do? Why?</li>
    <li>What will running <code>abdullah.type</code> do? Why? If you think it's broken, how can you fix it? If you think it works, what does it return?</li>
    <li>
      What is <code>abdullah</code>? Choose all that apply:
      <ul>
        <li>A class</li>
        <li>A method</li>
        <li>An instance</li>
        <li>An object</li>
        <li>A variable</li>
      </ul>
    </li>
  </ol>
</p>
{% if page.answers_shown %}
<a class="hover-show pull-right">Hover for answer</a>
<div class="hover-hide">
  <p>
    <ol>
      <li>Line 3 tells the class to save the name that was passed to it when you call <code>Person.new</code>. Without it, the class won't remember the name.</li>
      <li>Subclass</li>
      <li>It will break, because the method is only defined on the instance, not the class. You have to do <code>c = Christian.new(...)</code>, then <code>c.go_to_mass</code></li>
      <li><code>abdullah.type</code> will break becuase there's no <code>type</code> method in <code>Person</code> or <code>Christian</code> class.</li>
      <li>
        An instance, an object and a variable.
      </li>
    </ol>
  </p>
</div>
{% endif %}
<h4>Raise a Glass to Glasses</h4>
<p>
  Now consider these classes:
  <pre><code>class Container
  def fill_up
    @full = true
  end
  def empty_out
    @full = false
  end
end

class ThingThatBreaks
  def break
    @broken = true
  end
  def fix
    @broken = false
  end
end

class Glass < <span class="comment"># What should go here?</span>
end</code></pre>
</p>
<p>
  We want <code>Glass</code> to be both a <code>Container</code> (meaning we can fill it up and empty it out) AND be a <code>ThingThatBreaks</code>, meaning it should be able to break and fix itself. But it can't inherit from two different classes.
</p>
<p>
  This is why we use modules.
  <pre><code>module Breakable
  def break
    @broken = true
  end
  def fix
    @broken = false
  end
end

class Glass < Container
  include Breakable

  def fill_up_with_wine
    puts "Stayin' classy"
  end
end

class ShotGlass < Glass
  def fill_up_with_tequila
    puts "party == on"
  end
end

shot_glass = ShotGlass.new</code></pre>
</p>
<p>
  <ol start="6">
    <li>Will all this code work? Do you see any bugs? Before you try it yourself, write down your answer. If you see bugs, note what they are and how you would fix them.</li>
    <li>Will <code>shot_glass.break</code> work? Why or why not?</li>
    <li>In the code, we're calling <code>ShotGlass.new</code>, even though the <code>new</code> method isn't <code>def</code>'d anywhere. How come it works?</li>
    <li>What is <code>Breakable</code>? Choose all that apply:
      <ul>
        <li>A class</li>
        <li>A method</li>
        <li>An instance</li>
        <li>An object</li>
        <li>A variable</li>
      </ul>
    </li>
  </ol>
</p>
{% if page.answers_shown %}
<a class="hover-show pull-right">Hover for answer</a>
<div class="hover-hide">
  <ol start="6">
    <li>Yes.</li>
    <li>Will work, because it inherits from a class that includes <code>Breakable</code>, and therefore pulls in all the methods as well.</li>
    <li>Ruby automatically defines a <code>new</code> method on each class, so we can create instances of that class.</li>
    <li>An object (and also a module).</li>
  </ol>
</div>
{% endif %}
<h2>E2: String Theory</h2>
<p>
  A common way to practice arrays and methods is to write <em>string manipulation</em> methods, or methods that modify strings. The cool thing about Ruby is that you can always modify any class and add methods to it. For example, instead of our <code>shout</code> method, we could have written it into the <code>String</code> class itself:
</p>
<pre><code>class String
  def shout
    self.upcase
  end
end

"hElLo".shout
<span class="string"># => "HELLO"</span></code></pre>
<p>
  For this exercise, we're going to add some methods to the <code>String</code> class. Create <code>d4/super_strings.rb</code>.
</p>

<h4>Iglatinpay</h4>
<p>
  You may be familiar with <em>Piglatin</em>, which is a language just like English, but each first letter of a word is put at the end and followed by "ay". So, "Piglatin" in Piglatin is "Iglatinpay", and "iglatinpay" is "glatinpayiay". Write a method <code>piglatinify</code> to get this behavior.
</p>
<h4>Histay Siay Iglatinpay</h4>
<p>
  Write a method <code>piglatinify_sentence</code> that makes each word in a sentence into Piglatin.
</p>
<h4>Strip Down</h4>
<p>
  Write the method <code>strip</code> (but call it <code>strip_new</code>). Test it against Ruby's strip with a variety of test samples. Does it always behave the same?
</p>

<pre><code><span class="comment"># super_strings.rb</span>

# Your code here

"piglatin".piglatinify
<span class="comment"># => "iglatinpay"</span>
"Piglatin".piglatinify
<span class="comment"># => "Iglatinpay" (watch out for capital letters!)</span>
"This is Piglatin".piglatinify_sentence
<span class="comment"># => "Histay siay Iglatinpay"</span>
" 
tripsay emay \t ".strip_new
<span class="comment"># => "tripsay emay"</span>
</code></pre>

<h2>E3: Modulify</h2>
<p>
  Make your Piglatin methods into a module called <code>Piglatinify</code> in <code>piglatinify.rb</code>. The two methods should work on any class (perhaps the <code>to_s</code> method will come in handy here). Test by creating another file.
</p>
<pre><code><span class="comment"># d4/some_other_file.rb</span>

require_relative 'piglatinify'

class Array
  include Piglatinify
end
[:a, :b, :c].piglatinify
<span class="comment"># => ":a, :b, :c][ay"</span>
[:a, :b, :c].piglatinify_sentence
<span class="comment"># => ":a,[ay b,:ay c]:ay"</span></code></pre>

<h2>E4: Finding things</h2>
<p>
  One of the best uses of a computer is to find things—meaning information or other data. Facebook finds what your friends are doing, Buzzfeed finds things you kind of care about, and even Bing finds things sometimes, too. For this exercise, you're going to write your own code that finds things.
</p>
<h4>Thing = letter in string</h4>
<p>
  Write a method <code>index_of</code> that takes two paramters, a string and a letter. Return the index of the first time the letter occurs in that string, or -1 if it doesn't occur.
</p>

<h4>Thing = item in array</h4>
<p>
  Write a method <code>find_by_name</code>, which takes an array of hashes, each of which has the property <code>:name</code>, and a string and finds the first one that has that name.
</p>
<h4>Thing = items in array</h4>
<p>
  Write a second, very similar method <code>filter_by_name</code>, which returns and array with <b>all</b> the items with the given name. Note that that method should always return an array, even if only one item is found.
</p>
<pre><code><span class="comment"># finding_things.rb</span>

# Your code here

index_of("abcdefghijklmnop", "m")
<span class="string"># => 12</span>
index_of("abcdefghijklmnop", "z")
<span class="string"># => -1</span>

people = [
  {
    :id => 1,
    :name => "bru"
  },
  {
    :id => 2,
    :name => "ski"
  },
  {
    :id => 3,
    :name => "brunette"
  },
  {
    :id => 4,
    :name => "ski"
  }
]
find_by_name(people, "ski")
<span class="string"># => {:id=>2,:name=>"ski"}</span>
find_by_name(people, "kitten!")
<span class="string"># => nil</span>
filter_by_name(people, "ski")
<span class="string"># => [{:id=>2,:name=>"ski"}, {:id=>4,:name=>"ski"}]</span>
filter_by_name(people, "bru")
<span class="string"># => [{:id=>1,:name=>"bru"}] (Note this is still an array)</span>
filter_by_name(people, "puppy!!!")
<span class="string"># => []</span>
</code></pre>


<hr class="large">

<!-- Projects -->
<h1>Projects</h1>
<h2>Ruby: Fueling Consumerism</h2>
<p>
  Now that you have a beautiful presence on the Internet, we're going to work on bringing one of the most notable American vices to South Africa: consumerism. Over the next two days, you'll use your new knowledge of Ruby—with all its Hashes and Classes—to build a Shopping Cart and some Shoppers. It will closely model something you might build in a Rails application some day.
</p>
<h4>
  The Goods
</h4>
<p>
  To start, create a <code>shopping_cart</code> folder in your <code>projects</code> directory. We'll start with an <code>Item</code> class, so in <code>shopping_cart</code>, create a file called <code>item.rb</code>. Item is the simplest: it just has a <code>name</code> and a <code>price</code>. Copy the below code into it:
</p>
<pre><code><span class="comment"># item.rb</span>

class Item
  # @param{string} name The item's name
  # @param{float} price The item's price
  def initialize(name, price)
  end

  # Accessor methods

  # Returns name
  def name
  end

  # Returns price
  def price
  end
end</code></pre>
<p>
  This code doesn't do anything yet, but should be simple to fill out. Go ahead and do so, just like we did in lecture.
</p>
<h4>
  The Vehicle
</h4>
<p>
  Next we're going to build a <code>Cart</code> class that will hold all of the items, as well as how many items there are. Put this in a new file, <code>cart.rb</code>. This cart will closely resemble <a href="./2B.html">Lesson 2B, Exercise 5</a>, so feel free to borrow and modify code from there. To start, here's a template:
</p>
<pre><code><span class="comment"># cart.rb</span>

class Cart
  def initialize
  end

  # @return{Array&lt;Item&gt;}
  #   The items and their quantities in the cart, keyed by item name.
  def items
  end

  # @return{float} The total price of all the goods in the cart.
  def total_price
  end

  # @param{Item} item The item to add. 
  def add(item)
  end

  # @param{Item} item The item to remove. 
  def remove(item)
  end
end</code></pre>
<p>
The exact specification is as follows:
<ul>
  <li>
    Cart should keep an instance variable called <code>@items</code>.
    <code>@items</code> will be an <code>Array</code>, that holds Objects of the <code>Item</code> class. That is, the signature of <code>@items</code> is <code>Array&lt;Item&gt;</code>.
  </li>
  <li><code>@items</code> will start (be initialized) as an empty array.</li>
  <li>
    <code>Cart</code> will have a method <code>add</code> that adds <code>Item</code>s to its <code>@items</code> array.
  </li>
  <li>
    <code>Cart</code> has a method <code>remove</code> that will remove <b>all</b> instances of an item from its cart. That is, if <code>@items</code> is <code>[milk, milk, eggs]</code> and I run <code>cart.remove(milk)</code>, then <code>@items</code> should be <code>[eggs]</code>.
  </li>
  <li>
    <code>total_price</code> returns a <code>float</code> of the total price of all items in the cart. 
  </li>
</ul>
</p>
<p>
Like in the slides, let's create a <code>main.rb</code> that we'll use to test. This is a sample of how you might test it:
</p>
<pre><code><span class="comment"># main.rb</span>

require_relative 'item'
require_relative 'cart'
milk = Item.new("milk", 1.20)
eggs = Item.new("eggs", 1.30)
cart = Cart.new
cart.add(milk)
cart.add(milk)
cart.add(eggs)
p cart.items
<span class="string"># Console output might look like (but less well formatted, and the long 0x00... 
numbers might be different):

[
  #&lt;Item:0x00000103083438 @name="milk", @price=1.2&gt;,
  #&lt;Item:0x00000103083438 @name="milk", @price=1.2&gt;,
  #&lt;Item:0x000001012407f0 @name="eggs", @price=1.3&gt;
]</span>
p cart.total_price
<span class="string"># 3.7</span>
cart.remove(milk)
p cart.total_price
<span class="string"># 1.3</span></code></pre>
<p>
After you think you have a working answer, download the test file from <a href="../tests/shopping_cart_test_1.rb" target="_blank">here</a> and put it in your <code>shopping_cart</code> directory (just do File -> Save from Chrome). Run it with <code>ruby shopping_cart_test_1.rb</code>. If you're failing any tests, make them pass.
</p>
<!--
<h4>Add Some Mustard</h4>
<p>
  To spicen up your code, implement the following:
  <ul>
    <li>
      Give each item a <code>weight</code> property, and the <code>Cart</code> a <code>total_weight</code> method.
    </li>
    <li>
      Make it so you can't create two <code>Item</code>s with the same name. That is, the below should fail (i.e. not create the second milk):
      <ul>
        <code>
          Item.new("milk", 2)<br>
          Item.new("milk", 3)
        </code>
      </ul>
      This will involve research into <b>class methods and properties</b>.
    </li>
  </ul>
</p>
-->
