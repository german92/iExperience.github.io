# Methods & Objects

---

So far, we have been invoking methods on a variety of different things (Strings, Arrays, etc.). Let's review those cases and see if we can find any common patterns.

---

# Calling Methods
### on Arrays

```ruby
>> numbers = [1,2,3]
=> [1,2,3]

>> numbers.push(4)
=> [1,2,3,4]

>> numbers.size
=> 4

>> numbers.each do |number|
>>  puts number
>> end
```

---

# Calling Methods
### on Strings

```ruby
>> x = "hello"
=> "Hello"

>> x.upcase
=> "HELLO"

>> x.downcase
=> "hello"

>> x.size
=> 5
```

---

# Calling Methods
### on Integers

```ruby
>> x = 5
=> 5

>> x.to_s
=> "5"

>> puts x.to_s + " days left"
=> "5 days left"

>> puts "#{x} days left"
=> "5 days left"

```

---

## What do they have in common?
### Strings, Numbers, Arrays

* They hold data
* They can be stored in variables
* They have methods you can call on them
* They are all *objects*!

---

__In Ruby, everything is an Object.__

---

# Things We Know About Objects

1. The basic building blocks (atoms) of Ruby
2. Every object has a type, known as its __Class__ (String, Fixnum (Integer), Array)

---

# Classes of Objects
* __String__ is a Class of Object to hold text data
* __Fixnum__ is a Class of Object to hold integers/numbers
* __Array__ is a Class of Object to hold lists of other objects (e.g strings and numbers)

---

## Use the .class method to discover its class

```ruby
>> "Hello".class
=> String

>> 5.class
=> Fixnum

>> [1,2,3].class
=> Array

```

---

# Things We Know About Objects

1. The basic building blocks of Ruby
2. Every object has a __Class__ (String, Fixnum (Integer), Array)
3. All objects have __Methods__ you can call on them, based on their class

---

# What are Methods again?

* __Methods__ are commands that can be called on objects to perform work
* Depending on which __Class__ of Object it is, it has different methods
* All objects *inherit* methods from the Object class, because every Class *inherits* from Object

```ruby
>> "hello".upcase
=> "HELLO"
>> [1,2,3].join
=> "123"
>> 4.to_s
=> "4"
>> [1,2,3].to_s
=> "[1,2,3]"
```

---

# Things We Know About Objects

1. The basic building blocks of Ruby
2. Every object has a __Class__ (String, Fixnum (Integer), Array)
3. All objects have __Methods__ you can call on them, based on their class
4. __Instances__ of objects hold __data__, based on their class

---

# Instances of Objects

* This is an __instance__ of the __String__ class:

```ruby
>> "Hello"
```

* This is an __instance__ of the __Fixnum__ (Integer) class:

```ruby
>> 1
```

* This is an __instance__ of the __Array__ class:

```ruby
>> [1,2,3]
```

---

# Why does this matter?

* It's important to know the terminology of **classes**, **objects** and **instances** as early as possible so you can differentiate between them
* It's okay if you don't get it right away; these will be reinforced repeatedly

---

# Review

* **Classes** are the types of a given object. They determine what kinds of methods it has (i.e. the species)
* **Methods** are functions/procedures you can call on instances of objects (i.e. what the species can do)
* **Instances** are incarnation of objects of a specified class (i.e a single animal of the given species)
* **Objects** are the basic building blocks of Ruby that everything is built off of (i.e. atoms)
* **Variables** store instances of objects with a variable name you can reference (i.e. the same way we give each other unique names to remember who we are)

---

# Defining Methods

---

As behavior starts to get more complex, we will occasionally want to group our own code into logical sections by writing our own methods.

---

# Simple Method Example

```ruby

def say_hello
	puts "Hello"
end

say_hello

```

---

### Once a method is defined, you can call it as many times as you want
### This is referred to as 'invoking' the method

---

# Invoking Methods

```ruby

def shout_hello
	puts "HELLO!"
end

shout_hello
shout_hello
shout_hello

3.times do
  shout_hello
end

```

---

### You can pass a method 'arguments' to make it behave differently

---

# Method w/ Arguments

```ruby

def say(message)
	puts message
end

say("Hey")
say "Hi"

```

---

# Method w/ Arguments
### Modifying the argument

```ruby

def shout(message)
	puts message.upcase + "!"
end

shout("hi")

# String Interpolation:
def shout(message)
	puts "#{message.upcase}!"
end

shout("hi")
```

---

# Why Define Methods?

* The #1 motivation for methods is to stay DRY
* DRY: Don't Repeat Yourself
* Duplicated code is expensive to maintain

---

# Duplication Example: Cart

```ruby
cart = []

# Go Shopping!
cart.push("Eggs")
cart.push("Milk")
cart.push("Cheese")
puts "Done shopping! I bought #{cart.size} items."

# Put stuff in car
cart.delete_all

# Go Shopping Again!
cart.push("Eggs")
cart.push("Milk")
cart.push("Cheese")
puts "Done shopping! I bought #{cart.size} items."
```

---

# DRY'd Up Example: Cart

```ruby
def go_shopping(cart)
	cart.push("Eggs")
	cart.push("Milk")
	cart.push("Cheese")
	puts "Done shopping! I bought #{cart.size} items."
end

my_cart = []

go_shopping(my_cart)
cart.delete_all

go_shopping(my_cart)
cart.delete_all
```

---

# CODE-ALONG

## Tweet Analyzer w/ Methods!

---

# EXERCISES

[http://iexperience.github.io/exercises/3A.html](http://iexperience.github.io/exercises/3A.html)