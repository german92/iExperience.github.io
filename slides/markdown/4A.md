# Defining Classes

---
# Review: Objects

Every single instance<br/> of every type of class in Ruby is an Object, because every instance has a class, and every class inherits from Object.

---
## Testing Object Classes

```ruby
>> ([1,2,3].class == Array)
=> true

>> [1,2,3].is_a?(Array)
=> true

>> [1,2,3].is_a?(Object)
=> true

>> [1,2,3].instance_of?(Array)
=> true

>> [1,2,3].instance_of?(Object)
=> false
```
--

The ```is_a?``` method checks if the object is an instance of the given class, OR if the given class is a parent class of its class.
<br/><br/>
The ```instance_of?``` method only returns true if the object is an instance of the given class.

---
<br/><br/>
Every object will __respond__<br/> to certain methods based on its class.

---
# ```respond_to?```

```ruby
>> [1,2,3].respond_to?(:size)
=> true

>> [1,2,3].respond_to?(:keys)
=> false

>> {:jersey => 23}.respond_to?(:keys)
=> true
```

---

In Ruby, we pass around Objects without specifying what type/class they are in method arguments.
<br/><br/>
As a result, within a given method, we only care whether an object __responds__ to a given method, rather than worrying about what class it is.

---
# Duck Typing

"I don't really care what type of Object this is. If it responds to .size, .push, and .max, it does everything I need."
<br/><br/>
"Even if it's not actually of class Array, it behaves like one to me. If it quacks like a duck..."

---

# Employees Example

```ruby
salman = {:age => 29, :first_name => 'Salman', :last_name => 'Ansari'}

def get_full_name(person)
	"#{person[:first_name]} {person[:last_name]}"
end

get_full_name(salman)

```

---

The method 'get_full_name' now can be called by anyone, being passed any parameter. This is not ideal.

---

Object-Oriented Programming dictates that we should encapsulate data and behavior inside relevant objects, so that concerns are separated appropriately

---

In other words, an object should know how to store and change its own data. The whole world does not need to know how to work with an object's inner details.

---
### Employees Example Revisited

```
class Employee
	def initialize(age, first_name, last_name)
		@age = age # this is an instance variable
		@first_name = first_name
		@last_name = last_name
	end
end

salman = Employee.new(29, 'Salman', 'Ansari')
```

---
### Employees Example Revisited

```ruby
class Employee
	def initialize(age, first_name, last_name)
		@age = age # this is an instance variable
		@first_name = first_name
		@last_name = last_name
	end

	def age
		@age
	end

	def full_name
		"#{@first_name} #{@last_name}"
	end
end

# ...
```

--


```ruby
salman = Employee.new(29, 'Salman', 'Ansari')

salman.age
# => 29

salman.full_name
# => 'Salman Ansari'
```

---

# Key Concepts

* Declare a class with ```class ClassName...end```
* Define methods inside the class with ```def method_name...end```
* Instantiate an instance of a Class with .new
* Call methods on the instance just like with Array/String/etc

---

### Instance Variables vs Local Variables

* Local variables are defined inside a block or method, and will go away once the block or method has completed
* Instance variables are defined inside a class method, and will continue to live as long as the instance is alive
* Local variables have no special syntax (```count = 0```), and look the same as Method calls
* Instance variables using @ syntax (```@age = 29```)

---

Result: Now only Employee class knows how to generate full names from first and last names. Furthermore, we have a much simpler way of storing employees, accessing their info, and manipulating it.

---
### Multiple Classes

```ruby
class Engineer
	def initialize(age, first_name, last_name)
		@age = age
		@first_name = first_name
		@last_name = last_name
	end

	def full_name
		"#{@first_name} #{@last_name}"
	end
end

salman = Engineer.new(20, 'Salman', 'Ansari')

# Cont'd below...
```

--

```ruby
class Designer
	def initialize(age, first_name, last_name, website)
		@age = age
		@first_name = first_name
		@last_name = last_name
		@website = website
	end

	def full_name
		"#{@first_name} #{@last_name}"
	end
end

aaron = Designer.new(20, 'Aaron', 'Fuchs', 'iexperience.co.za')

```
---
### Class Inheritance

* You can use class inheritance to share methods between classes, if they are duplicated
* You can have as many classes as you want inheriting from a parent class
* Class inheritance is achieved through the class declaration (```class Child < Parent ... end```)

---
### Sharing Methods via Class Inheritance
```ruby
class Employee
	def full_name
		"#{@first_name} #{@last_name}"
	end
end

class Engineer < Employee
	def initialize(age, first_name, last_name)
		@age = age
		@first_name = first_name
		@last_name = last_name
	end
end

# Cont'd below...
```

--

```ruby
class Designer < Employee
	def initialize(age, first_name, last_name, website)
		@age = age
		@first_name = first_name
		@last_name = last_name
		@website = website
	end
end
```
---

As the number of classes declared increases, we will want to separate out each Ruby Class declaration into its own file

---
```ruby
# in employee.rb
class Employee
	...
end
# in engineer.rb
class Engineer
	...
end
# in designer.rb
class Designer
	...
end

# in main.rb
require_relative 'employee'
require_relative 'engineer'
require_relative 'designer'

salman = Engineer.new(20, 'Salman', 'Ansari')
aaron = Designer.new(20, 'Aaron', 'Fuchs', 'http://www.iexperience.co.za')
```
---

While we are just working with Ruby, a good practice is to have a single ```main.rb``` file with your entire program in it, which requires any other classes it needs in order to function using ```require_relative```

---

# CODE-ALONG
## Petitions + Reddit = Stories

Solution: https://github.com/iExperience/stories

---

#### What if you wanted to inherit from multiple classes at once?

You can't.

However, you CAN get methods from multiple places if those methods are stored in Modules, rather than Classes.

---
# What is a Module?

* A module is similar to a class in that you can define methods in it
* However, you cannot create an instance of a Module
* The only thing you can do with a Module is ```include``` it in a class, which will give that class all the Module's methods

---

```ruby
module HelpfulStuff
	def full_name
		"#{@first_name} #{@last_name}"
	end
	def initials
		"#{@first_name[0]}#{@last_name[0]}"
	end
end
class Employee
	include HelpfulStuff
end

salman = Employee.new(20, 'Salman', 'Ansari')
salman.full_name
# => Salman Ansari
salman.initials
# => SA
```
---
## Why should we care about Modules?

Rails uses Modules extensively to provide various functionality, and they are a common paradigm for writing simple helper libraries that many classes can easily leverage.

For now, it's sufficient to have basic understanding of them (i.e. how to define them & how to include them so you can call their methods on class instances).

---
## Modules vs Classes

* Classes have methods *and* data in them. You can inherit their methods by using class inheritance.
* Classes can be instantiated to get instances of that class.
* Modules only have methods in them, that can be *included* into a class.
* You can include as many Modules as you like in your class.
* Modules *cannot* store data, and *cannot* be instantiated.

---
# Summary

* We can define our own classes with custom methods
* We can instantiate classes and call methods on those object instances
* We can use instances of classes to store data (through instance variables)
* We can use class inheritance to share methods between classes
* We can define Modules and include them in classes to get their methods

---
# EXERCISES

[http://iexperience.github.io/exercises/4A.html](http://iexperience.github.io/exercises/4A.html)