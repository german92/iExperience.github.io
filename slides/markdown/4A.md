# REVIEW

* We learned that Strings, Integers, Arrays, etc. are all Objects
* The __objects__ we work with are __instances__ of a Class
* Depending on what __class__ an object is, it has different methods you can call on it
* We can define methods using ```def foo ... end```
* Methods are primarily used to DRY up your code
* The last line (statement) of a method is the return value
* Only local variables declared __within__ a method are accessible inside the method
* We learned how to make API calls using RestClient

---

# Defining Classes

---
# Why Define Classes?

* To group behavior (methods) that are related (i.e. they operate on similar data or do similar work)
* To group data (variables) that are related (e.g. different attributes of a Person)

---
# What's wrong with just using methods?

* The method 'get_full_name' now can be called by anyone, being passed any parameter. This is not ideal.
* Object-Oriented Programming dictates that we should encapsulate data and behavior inside relevant objects, so that concerns are separated appropriately
* An object should know how to store and change its own data. The whole world does not need to know how to work with an object's inner details.

---

# Employees Example

```ruby
salman = {:age => 29, :first_name => 'Salman', :last_name => 'Ansari'}

def get_full_name(person)
	"#{person[:first_name]} {person[:last_name]}"
end

get_full_name(salman)

```

---
### Employees Example Revisited

```
class Employee
	def initialize(age, first_name, last_name)
		@age = age # this is an instance variable
		@first_name = first_name
		@last_name = last_name
	end
end

salman = Employee.new(29, 'Salman', 'Ansari')
```

---
# Instances
## have instance variables

* An instance of a class is an object that stores data using instance variables
* Instance variables are denoted with an @ (vs. local variables which do not have any special denotation)
* Instance variables live as long as the object instance lives
* Instance variables are shared between methods within the instance

---

### Instance Variables vs Local Variables

* Local variables are defined inside a block or method, and will go away once the block or method has completed
* Instance variables are defined inside a class method, and will continue to live as long as the instance is alive
* Local variables have no special syntax (```count = 0```), and look the same as Method calls
* Instance variables using @ syntax (```@age = 29```)

---

### Employees Example Revisited

```ruby
class Employee
	def initialize(age, first_name, last_name)
		@age = age # this is an instance variable
		@first_name = first_name
		@last_name = last_name
	end

	def age
		@age
	end

	def full_name
		"#{@first_name} #{@last_name}"
	end
end

# ...
```

--


```ruby
salman = Employee.new(29, 'Salman', 'Ansari')

salman.age
# => 29

salman.full_name
# => 'Salman Ansari'
```

---
# Instance Variable Scope

Instance variables are shared across all methods within a Class.

```ruby
class Person
	def initialize(age, sex, location)
		@age = age
		@sex = first_name
		@location = last_name
	end

	def a_s_l
		"#{@age} / #{@sex} / #{@location}"
	end
end
```

---

# Key Concepts

* Declare a class with ```class ClassName...end```
* Define methods inside the class with ```def method_name...end```
* Instantiate an instance of a Class with .new
* Call methods on the instance just like with Array/String/etc
* Use classes to encapsulate shared __behavior and data__

---
# Encapsulating Behavior

If you have a bunch of methods that are related to each other, they probably belong in a class together.

---
# Encapsulating Data

If you have a bunch of data (e.g. info about a Person) that is related, it probably belongs inside of a class as instance variables.

---

Result: Now only Employee class knows how to generate full names from first and last names. Furthermore, we have a much simpler way of storing employees, accessing their info, and manipulating it.

---
### Multiple Classes

```ruby
class Engineer
	def initialize(age, first_name, last_name)
		@age = age
		@first_name = first_name
		@last_name = last_name
	end

	def full_name
		"#{@first_name} #{@last_name}"
	end
end

salman = Engineer.new(20, 'Salman', 'Ansari')

# Cont'd below...
```

--

```ruby
class Designer
	def initialize(age, first_name, last_name, website)
		@age = age
		@first_name = first_name
		@last_name = last_name
		@website = website
	end

	def full_name
		"#{@first_name} #{@last_name}"
	end
end

aaron = Designer.new(20, 'Aaron', 'Fuchs', 'iexperience.co.za')

```
---
### Class Inheritance

* You can use class inheritance to share methods between classes, if they are duplicated
* You can have as many classes as you want inheriting from a parent class
* Class inheritance is achieved through the class declaration (```class Child < Parent ... end```)

---
### Sharing Methods via Class Inheritance
```ruby
class Employee
	def full_name
		"#{@first_name} #{@last_name}"
	end
end

class Engineer < Employee
	def initialize(age, first_name, last_name)
		@age = age
		@first_name = first_name
		@last_name = last_name
	end
end

# Cont'd below...
```

--

```ruby
class Designer < Employee
	def initialize(age, first_name, last_name, website)
		@age = age
		@first_name = first_name
		@last_name = last_name
		@website = website
	end
end
```
---

As the number of classes declared increases, we will want to separate out each Ruby Class declaration into its own file

---
```ruby
# in employee.rb
class Employee
	...
end
# in engineer.rb
class Engineer
	...
end
# in designer.rb
class Designer
	...
end

# in main.rb
require_relative 'employee'
require_relative 'engineer'
require_relative 'designer'

salman = Engineer.new(20, 'Salman', 'Ansari')
aaron = Designer.new(20, 'Aaron', 'Fuchs', 'http://www.iexperience.co.za')
```
---

While we are just working with Ruby, a good practice is to have a single ```main.rb``` file with your entire program in it, which requires any other classes it needs in order to function using ```require_relative```

---

# CODE-ALONG
## Petitions + Reddit = Stories

Solution: https://github.com/iExperience/stories

---

# Food for Thought
## How does an Object instance get methods?

1. If methods are defined on that object's Class (e.g. String)
2. If methods are defined on the object's Class's parent Class (e.g. Object)
3. If methods are defined on the object's Class's parent Class's parent class...

---

## Testing Object Classes

```ruby
>> ([1,2,3].class == Array)
=> true

>> [1,2,3].is_a?(Array)
=> true

>> [1,2,3].is_a?(Object)
=> true

>> [1,2,3].instance_of?(Array)
=> true

>> [1,2,3].instance_of?(Object)
=> false
```
---
# Analogies

Imagine we had Classes to categories animals on this planet.

```ruby
@cat = Cat.new

@cat.instance_of?(Cat)
# => true

@cat.instance_of?(Dog)
# => false

@cat.is_a?(Dog)
# => false

@cat.is_a?(Animal)
# => true

@cat.instance_of?(Animal)
# => false
```
---

The ```is_a?``` method checks if the object is an instance of the given class, OR if the given class is a parent class of its class.
<br/><br/>
The ```instance_of?``` method only returns true if the object is an instance of the given class.

---

An object inherits methods not just from its parent class, but from its entire __ancestry__ of classes.

---

Q. How can we tell if an Object supports a particular method?
A. ```respond_to?```

```ruby
>> [1,2,3].respond_to?(:size)
=> true

>> [1,2,3].respond_to?(:keys)
=> false

>> {:jersey => 23}.respond_to?(:keys)
=> true
```

---

In Ruby, we pass around Objects without specifying what type/class they are in method arguments.
<br/><br/>
As a result, within a given method, we only care whether an object __responds__ to a given method, rather than worrying about what class it is.

---
# Duck Typing

"I don't really care what type of Object this is. If it responds to .size, .push, and .max, it does everything I need."
<br/><br/>
"Even if it's not actually of class Array, it behaves like one to me. If it quacks like a duck..."


#### What if you wanted to inherit from multiple classes at once?

You can't.

However, you CAN get methods from multiple places if those methods are stored in Modules, rather than Classes.

---
# What is a Module?

* A module is similar to a class in that you can define methods in it
* However, you cannot create an instance of a Module
* The only thing you can do with a Module is ```include``` it in a class, which will give that class all the Module's methods

---

```ruby
module HelpfulStuff
	def full_name
		"#{@first_name} #{@last_name}"
	end
	def initials
		"#{@first_name[0]}#{@last_name[0]}"
	end
end
class Employee
	include HelpfulStuff
end

salman = Employee.new(20, 'Salman', 'Ansari')
salman.full_name
# => Salman Ansari
salman.initials
# => SA
```
---
## Why should we care about Modules?

Rails uses Modules extensively to provide various functionality, and they are a common paradigm for writing simple helper libraries that many classes can easily leverage.

For now, it's sufficient to have basic understanding of them (i.e. how to define them & how to include them so you can call their methods on class instances).

---
## Modules vs Classes

* Classes have methods *and* data in them. You can inherit their methods by using class inheritance.
* Classes can be instantiated to get instances of that class.
* Modules only have methods in them, that can be *included* into a class.
* You can include as many Modules as you like in your class.
* Modules *cannot* store data, and *cannot* be instantiated.

---
# Summary

* We can define our own classes with custom methods
* We can instantiate classes and call methods on those object instances
* We can use instances of classes to store data (through instance variables)
* We can use class inheritance to share methods between classes
* We can define Modules and include them in classes to get their methods

---
# EXERCISES

[http://iexperience.github.io/exercises/4A.html](http://iexperience.github.io/exercises/4A.html)